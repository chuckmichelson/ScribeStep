<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WikiLibrary Live</title>
<style>
  html,body{
    margin:0;height:100%;
    background:#222;color:#e9ecf5;font:14px/1.3 system-ui;
  }

  /* Center canvas + UI horizontally, stacked vertically */
  body{
    display:flex; flex-direction:column; align-items:center;
    padding:12px;
  }

  canvas{
    display:block; max-width:100vw; height:auto; background:#000;
  }

  /* Centered, compact toolbar under the canvas */
  #ui{
    display:inline-flex;            /* shrink to content */
    align-items:center; gap:12px;
    padding:8px 12px;
    margin:12px auto 0;             /* center the bar */
    background:#222;                /* requested UI background */
    border:1px solid #333;
    border-radius:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  #ui>*{font:12px system-ui}
  .pill{padding:2px 6px;border-radius:999px;background:#203060;color:#cfe}
  #ui select{
    background:#222; color:#e9ecf5; border:1px solid #444; border-radius:8px;
    padding:4px 8px;
  }
  /* #log{position:fixed; left:50%; transform:translateX(-50%); bottom:8px; ...} */
</style>

<body>
  <canvas id="c" width="1538" height="855"></canvas>

  <div id="ui" role="toolbar" aria-label="Controls">
    <span class="pill" id="status">connecting…</span>
    <label>Project
      <select id="language">
      </select>
    </label>
  </div>

<!-- <pre id="log"></pre> -->

<script>
  // Autonyms first; English fallback
  const LANGUAGES = [
    { code:'en',  domain:'en.wikipedia.org',  autonym:'English',         english:'English' },
    { code:'simple',domain:'simple.wikipedia.org', autonym:'Simple English', english:'Simple English' },
    { code:'es',  domain:'es.wikipedia.org',  autonym:'Español',         english:'Spanish' },
    { code:'fr',  domain:'fr.wikipedia.org',  autonym:'Français',        english:'French' },
    { code:'de',  domain:'de.wikipedia.org',  autonym:'Deutsch',         english:'German' },
    { code:'it',  domain:'it.wikipedia.org',  autonym:'Italiano',        english:'Italian' },
    { code:'pt',  domain:'pt.wikipedia.org',  autonym:'Português',       english:'Portuguese' },
    { code:'ru',  domain:'ru.wikipedia.org',  autonym:'Русский',         english:'Russian' },
    { code:'zh',  domain:'zh.wikipedia.org',  autonym:'中文',            english:'Chinese' },
    { code:'ja',  domain:'ja.wikipedia.org',  autonym:'日本語',          english:'Japanese' },
    { code:'ko',  domain:'ko.wikipedia.org',  autonym:'한국어',          english:'Korean' },
    { code:'ar',  domain:'ar.wikipedia.org',  autonym:'العربية',        english:'Arabic' },
    { code:'he',  domain:'he.wikipedia.org',  autonym:'עברית',          english:'Hebrew' },
    { code:'hi',  domain:'hi.wikipedia.org',  autonym:'हिन्दी',         english:'Hindi' },
    { code:'bn',  domain:'bn.wikipedia.org',  autonym:'বাংলা',          english:'Bengali' },
    { code:'tr',  domain:'tr.wikipedia.org',  autonym:'Türkçe',         english:'Turkish' },
    { code:'vi',  domain:'vi.wikipedia.org',  autonym:'Tiếng Việt',     english:'Vietnamese' },
    { code:'fa',  domain:'fa.wikipedia.org',  autonym:'فارسی',          english:'Persian' },
    { code:'pl',  domain:'pl.wikipedia.org',  autonym:'Polski',          english:'Polish' },
    { code:'nl',  domain:'nl.wikipedia.org',  autonym:'Nederlands',      english:'Dutch' },
    { code:'sv',  domain:'sv.wikipedia.org',  autonym:'Svenska',         english:'Swedish' },
    { code:'nb',  domain:'no.wikipedia.org',  autonym:'Norsk bokmål',    english:'Norwegian Bokmål' },
    { code:'da',  domain:'da.wikipedia.org',  autonym:'Dansk',           english:'Danish' },
    { code:'fi',  domain:'fi.wikipedia.org',  autonym:'Suomi',           english:'Finnish' },
    { code:'cs',  domain:'cs.wikipedia.org',  autonym:'Čeština',         english:'Czech' },
    { code:'el',  domain:'el.wikipedia.org',  autonym:'Ελληνικά',        english:'Greek' },
    { code:'th',  domain:'th.wikipedia.org',  autonym:'ไทย',            english:'Thai' },
    { code:'id',  domain:'id.wikipedia.org',  autonym:'Bahasa Indonesia',english:'Indonesian' },
    { code:'uk',  domain:'uk.wikipedia.org',  autonym:'Українська',      english:'Ukrainian' },
    { code:'ro',  domain:'ro.wikipedia.org',  autonym:'Română',          english:'Romanian' },
    { code:'eo',  domain:'eo.wikipedia.org',  autonym:'Esperanto',       english:'Esperanto' },
  ];

  // Populate dropdown with autonyms (fallback to English)
  const langSelect = document.getElementById('language');
  LANGUAGES.forEach(({ code, domain, autonym, english }) => {
    const opt = document.createElement('option');
    opt.value = domain;                          // '' means “all”
    opt.textContent = autonym || english;
    if (code) opt.lang = code;                   // helps shaping for some scripts
    langSelect.appendChild(opt);
  });

  // Default to English project
  langSelect.value = 'en.wikipedia.org';

  // Wire into your existing “project” handling:
  function setProjectDomain(domain){
    // Example: update your EventStreams connection / state here
    state.projectDomain = domain; // or however you store it
    // reconnect / resubscribe as needed...
  }

  langSelect.addEventListener('change', e => setProjectDomain(e.target.value));

/* =======================
   CONFIG: assets & grid
   ======================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
// Choose the Teahouse cell (col,row). Change to taste.
const TEAHOUSE_CELL = { col: 1, row: 3 }; // zero-indexed in your 4×4 grid
const TEAHOUSE_URL  = 'https://en.wikipedia.org/wiki/Wikipedia:Teahouse';
// How long article badges persist after an actor departs (ms)
const ARTICLE_BADGE_MS = 4000;

// Linger badges (drawn even when the actor is gone)
const lingeringBadges = []; // {text, url, x, y, t0}

const ASSETS = {
  background: { src: 'fantasy_library.png' },   // <-- set to your background
  outdoors: { src: 'fantasy_outdoors.png' },   // <-- set to your background 
  newuseroverlay: { src: 'fantasy_library_newuser.png' },
  // Robot sprite sheet (your cute bot)
  robot: {
    img: { src: 'robot_sprite_sheet.png' },
    frames: {
      back: [ {x: 0,   y:0, w:221, h:277}, {x:221, y:0, w:221, h:277} ],
      side: [ {x: 442, y:0, w:221, h:277}, {x:663, y:0, w:220, h:277} ],
      scale: 0.18
    }
  },
  human: {
    img: { src: 'wikipedian_sprite_sheet.png' },   // <-- set to your human sheet
    frames: {
      // widths sum to 883: 221 + 221 + 221 + 220
      side:  [ {x: 420, y:0, w:320, h:811}, {x:   0, y:0, w:320, h:811} ],
      back:  [ {x: 824, y:0, w:320, h:811}, {x: 1240, y:0, w:320, h:811} ], // duplicate for a 2-frame loop
      scale: 0.10
    }
  },
  // Optional: tall ladder sprite (from your sheet); if omitted, we’ll draw a simple ladder
  ladder: {
    img: { src: 'ladder.png' },   // <-- set to your ladder
    frames: {
      side: [ {x: 0, y: 0, w: 222, h: 461}, {x: 0, y: 0, w: 222, h: 461} ],
      front:[ {x: 666, y: 0, w: 222, h: 461}, {x: 0, y: 0, w: 222, h: 461} ],
      back: [ {x: 444, y: 0, w: 222, h: 461}, {x: 0, y: 0, w: 222, h: 461} ],
      scale: 0.17
    }
  },};




// Canvas/grid target geometry (tweak to align with background shelves)
const GRID = {
  cols: 4,
  rows: 4,
  // Outer margins (px) from canvas edges to begin the 4×4 shelves grid
  margin: { left: 90, right: 90, top: 110, bottom: 120 },
  // Padding inside each shelf cell before placing a book “column/row”
  shelfPad: { x: 40, y: 40 },  // move the notional book area away from frames
  // Within each shelf, the book stack area width/height (auto-computed)
};

// Animation speeds (px/sec); tweak to taste
const SPEEDS = {
  walk: 120,
  climb: 100,
  exit: 100
};

// Event stream sampling & rules
const RULES = {
  maxActors: 1000,          // cap concurrent librarians
  holdTimeMs: 3000,       // time to “edit” at shelf before exiting
  namespace: '0'          // article namespace
};

// Convert DOM click coords to canvas coords (handles CSS scaling)
function toCanvasXY(evt){
  const b = canvas.getBoundingClientRect();
  const x = (evt.clientX - b.left) * (canvas.width  / b.width);
  const y = (evt.clientY - b.top)  * (canvas.height / b.height);
  return {x,y};
}

// Return topmost (last drawn) hit target under pointer
function getClickTarget(px,py){
  for (let i = state.actors.length - 1; i >= 0; i--){
    const a = state.actors[i];
    if (a.titleRect && ptInRect(px,py,a.titleRect)) return { kind:'article', actor:a };
  }
  return null;
}

// Pointer affordance + click
canvas.addEventListener('mousemove', (ev)=>{
  const p = toCanvasXY(ev);
  const tgt = getClickTarget(p.x, p.y);
  canvas.style.cursor = tgt ? 'pointer' : '';
});
canvas.addEventListener('click', (ev)=>{
  const p = toCanvasXY(ev);
  const tgt = getClickTarget(p.x, p.y);
  if (!tgt) return;
  const a = tgt.actor;
  if (tgt.kind === 'article'){
    const url = `https://${a.wikiHost}/wiki/${encodeURIComponent(a.title.replace(/ /g,'_'))}`;
    window.open(url, '_blank', 'noopener');
  }
});

/* =======================
   Placement & visual offsets
   ======================= */
// Hard nudges so feet hit the floor line nicely and ladder sits right
const OFFSETS = {
  robot: { x: 0, y: 0 },   // +y nudges down
  human: { x: 0, y: 4 },
  ladder: { x: -3, topHeadroom: 10, sideGap: 18 } // small tweaks for look
};

// const logEl = document.getElementById('log');
// function logLine(s){ logEl.textContent = (s + '\n' + logEl.textContent).slice(0, 4000); }



// Build 20 non-touching rectangles (4 rows × 5 cols) inside the canvas
// Each rect has inner padding to keep stacks off its edges
const LOCATIONS = (() => {
  const COLS = 5, ROWS = 4;
  const margin = { left: 0, right: 0, top: 0, bottom: 0 };
  const pad = { x: 70, y: 70 };   // inner padding within each rect
  const w = canvas.width, h = canvas.height;
  const innerW = w - margin.left - margin.right;
  const innerH = h - margin.top - margin.bottom;
  const cellW = innerW / COLS;
  const cellH = innerH / ROWS;

  const rects = [];
  for (let r=0; r<ROWS-1; r++){
    for (let c=0; c<COLS; c++){
      const x = margin.left + c*cellW;
      const y = margin.top  + r*cellH;
      rects.push({
        x, y, w: cellW, h: cellH,
        inner: { x: x + pad.x, y: y + pad.y, w: cellW - 2*pad.x, h: cellH - 2*pad.y }
      });
    }
  }
  return rects; // length 20
})();

/* =======================
   Helpers
   ======================= */

function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=>res(img);
    img.onerror = rej;
    img.src = src;
  });
}

function isNewUserEvent(e){
  // Wikimedia RC: account creations arrive as log events
  // type: "log", log_type: "newusers", log_action: "create" | "autocreate"
  return e && e.type === 'log' && e.log_type === 'newusers' && (e.log_action === 'create' || e.log_action === 'autocreate');
}

// Simple hash → 32-bit int (for deterministic shelf placement per title)
function hash32(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h >>> 0;
}

// From 0..1 seeded
function seededUnit(rand32){ return (rand32 % 100000) / 100000; }

function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function isIPUser(u){
  // IPv4 or IPv6-ish (loose but fine for display)
  return typeof u === 'string' && (/^\d{1,3}(\.\d{1,3}){3}$/.test(u) || u.includes(':'));
}

// wordlists for plausible names (short, readable)
const WORDS = {
  adj: ['Quiet','Gentle','Steady','Patient','Keen','Kind','Nimble','Careful','Bright','Calm','Soft','Clever','Mellow','Brisk','Warm'],
  noun: ['Juniper','Ash','Cedar','Maple','Willow','Sage','Laurel','Birch','Oak','Clover','Rowan','Iris','Ember','Quill','River']
};

// salt + rotation so names aren’t universally linkable
const PSEUDO = {
  salt: 'scribestep-v1',    // change if you want to rotate scheme
  rotate: 'day'            // 'none' | 'day'
};

function dayKeyUTC(){
  const d = new Date();
  return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`;
}

function pseudoFor(raw, isBot=false){
  // stable within a rotation period, different across days (or set rotate:'none')
  const basis = PSEUDO.salt + '|' + (PSEUDO.rotate==='day' ? dayKeyUTC() : '') + '|' + raw;
  const h = hash32(basis);
  const a = WORDS.adj[h % WORDS.adj.length];
  const n = WORDS.noun[(h>>>8) % WORDS.noun.length];
  const num = String((h>>>16) % 1000).padStart(3,'0');
  if (isBot) return `Auto-Scribe #${num}`;
  return `${a} ${n} #${num}`;
}

// function displayName(raw, isBot = false){
//   // Bots keep their original names (regardless of anonymize toggle)
//   if (isBot) return raw;

//   const anon = document.getElementById('anonNames').checked;

//   // When anonymization is OFF: show raw username; collapse IPs to "(IP)"
//   if (!anon) return isIPUser(raw) ? '(IP)' : raw;

//   // When anonymization is ON:
//   if (isIPUser(raw)) {
//     // Deterministic, non-reversible label for IP editors
//     return `Anon Scribe #${String(hash32('ip|' + raw) % 10000).padStart(4,'0')}`;
//   }
//   // Pseudonym for registered humans
//   return pseudoFor(raw, false);
// }

function displayName(raw){
  // const hide = document.getElementById('hideNames').checked;
  const hide = true;
  if (hide) return '';                    // hide all usernames (including bots & IPs)
  return isIPUser(raw) ? '(IP)' : raw;    // when shown, collapse IPs to a generic label
}


/* =======================
   Layout calculations
   ======================= */
function computeGrid(){
  const w = canvas.width, h = canvas.height;
  const innerW = w - GRID.margin.left - GRID.margin.right;
  const innerH = h - GRID.margin.top - GRID.margin.bottom;
  const cellW = innerW / GRID.cols;
  const cellH = innerH / GRID.rows;
  return { w, h, innerW, innerH, cellW, cellH };
}
function shelfRect(col,row){
  const g = computeGrid();
  const x0 = GRID.margin.left + col*g.cellW;
  const y0 = GRID.margin.top  + row*g.cellH;
  return { x: x0, y: y0, w: g.cellW, h: g.cellH };
}
// A semi-permanent per-title location: pick shelf (col,row) and local (u,v) 0..1 inside shelf
// Semi-permanent per-title location: pick one of the 20 rects, then uniform inside it
function pickArticleSlot(title){
  const h = hash32(title);
  const rectIndex = h % LOCATIONS.length;      // sticky rectangle choice (0..19)
  const rx = seededUnit(h >>> 7);              // 0..1
  const ry = seededUnit(h >>> 13);             // 0..1

  const R = LOCATIONS[rectIndex].inner;
  const x = R.x + rx * R.w;
  const y = R.y + ry * R.h;

  // Row 0..3 for floor line based on which row this rect is in (5 columns)
  const row = Math.floor(rectIndex / 5);
  return { rectIndex, row, x, y };
}

function floorYForShelfRow(row){ // 0 (top) .. 3 (bottom)
  const h = canvas.height;
  // Four “floors” spaced evenly; lift slightly so feet aren't clipped
  const bottom = ((row + 1) / 4) * h;
  return bottom - 20;
}

function sliceStrip(img, cols){
  const baseW = Math.floor(img.width / cols);
  const widths = Array(cols).fill(baseW);
  widths[cols - 1] = img.width - baseW * (cols - 1); // last frame eats remainder
  let x = 0;
  const rects = [];
  for (let i = 0; i < cols; i++){
    rects.push({ x, y: 0, w: widths[i], h: img.height });
    x += widths[i];
  }
  return rects;
}

// ---- rounded rect path
function roundRectPath(ctx, x, y, w, h, r){
  const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y,     x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x,     y + h, rr);
  ctx.arcTo(x,     y + h, x,     y,     rr);
  ctx.arcTo(x,     y,     x + w, y,     rr);
  ctx.closePath();
}

// ---- simple word-wrapping (monospace-ish UI font is fine for this)
function wrapLines(ctx, text, maxWidth){
  const words = String(text).split(/\s+/);
  const lines = [];
  let line = '';
  for (const w of words){
    const test = line ? (line + ' ' + w) : w;
    if (ctx.measureText(test).width <= maxWidth){
      line = test;
    } else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);
  return lines;
}

// ---- draw the title badge and return its hitbox
function drawTitleBadge(text, x, y, side, opts={}){
  // side: 'left' or 'right'; (x,y) is the TOP-LEFT corner if side==='left',
  // otherwise it's the TOP-LEFT of a box placed to the right of anchor.
  const pad = opts.padding ?? 8;
  const r   = opts.radius  ?? 10;
  const maxW= opts.maxWidth ?? Math.min(280, canvas.width * 0.22);
  const lineH = opts.lineHeight ?? 16;

  ctx.save();
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';

  const lines = wrapLines(ctx, text, maxW);
  const contentW = Math.max(24, ...lines.map(s => ctx.measureText(s).width));
  const w = Math.min(maxW, contentW) + pad*2;
  const h = lines.length * lineH + pad*2;

  // Adjust x if panel is on the right side (x is the anchor edge)
  const rectX = (side === 'right') ? x : x - w;
  const rectY = y;

  // Background
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'rgba(5,12,24,0.72)';
  roundRectPath(ctx, rectX, rectY, w, h, r);
  ctx.fill();

  // Text
  ctx.fillStyle = '#f6f7fb';
  let ty = rectY + pad;
  for (const s of lines){
    ctx.fillText(s, rectX + pad, ty);
    ty += lineH;
  }
  ctx.restore();

  return { x: rectX, y: rectY, w, h };
}

// ---- point-in-rect
function ptInRect(px, py, R){ return !!R && px >= R.x && px <= R.x + R.w && py >= R.y && py <= R.y + R.h; }

/* =======================
   Sprites
   ======================= */
class Sheet {
  constructor(img, frames, scale=1){ this.img=img; this.frames=frames; this.scale=scale; }
  draw(view, t, x, y, flip=false){
    const list = this.frames[view] || this.frames.side;
    const idx  = Math.floor(t*8)%list.length;
    const f = list[idx];
    const w = f.w * (this.frames.scale ?? this.scale ?? 1);
    const h = f.h * (this.frames.scale ?? this.scale ?? 1);
    ctx.save();
    ctx.translate(x, y);
    if (flip) { ctx.scale(-1,1); }
    ctx.drawImage(this.img, f.x, f.y, f.w, f.h, -w/2, -h, w, h);
    ctx.restore();
    return {w,h};
  }
}

let SPRITES = { bg:null, robot:null, human:null };

/* =======================
   Actor state machine
   ======================= */
class Actor {
  constructor(kind, rawUser, wikiHost, title, startSide, startRow, target, opts = {}){
    this.kind = kind;                   // 'robot' | 'human'
    this.rawUser = rawUser;             // store raw; anonymize at draw-time
    this.wikiHost = wikiHost;           // e.g., 'en.wikipedia.org'
    this.title = title;
    this.entrySide = startSide;         // -1 = left, +1 = right
    this.exitSide  = -startSide;        // leave opposite side
    this.floorY    = floorYForShelfRow(startRow);
    this.target    = { x: target.x, y: target.y };
    this.pos = { x: startSide===-1 ? -60 : canvas.width+60, y: this.floorY };
    this.faceLeft = (startSide!==-1);
    this.state = 'WALK_X';              // WALK_X → CLIMB_Y → EDIT → DESCEND_Y → EXIT
    this.holdUntil = 0;
    this.actorRect = null;
    this.titleRect = null;
    this.isNewUser = !!opts.isNewUser;
    // this.isNewUser = true;
    // NEW: for new users, always start offscreen left → head right
    const startX = (this.isNewUser ? -120 : (startSide===-1 ? -60 : canvas.width+60));
    this.pos = { x: startX, y: this.floorY };
    this.state = this.isNewUser ? 'GROUND_WALK' : 'WALK_X';
    this.newUserCalloutShown = false;   // becomes true after first trigger
    this.calloutT0 = 0;                 // animation start time
    this.calloutMs = 1500;              // how long the “New User!” floats/fades
  }

  update(dt){
    switch(this.state){
    // ----------------- NEW: Ground-floor new-user path -----------------
      case 'GROUND_WALK': {
        // Always move right at walk speed on the floor line
        this.faceLeft = false;
        this.pos.y = this.floorY;
        this.pos.x += SPEEDS.walk * dt;

        // Trigger callout once when crossing the midpoint
        const mid = canvas.width * 0.5;
        if (!this.newUserCalloutShown && this.pos.x >= mid){
          this.newUserCalloutShown = true;
          this.calloutT0 = performance.now();
        }

        // Leave screen right → done
        if (this.pos.x > canvas.width + 120){
          this.done = true;
        }
        break;
      }
      case 'WALK_X': {
        const dx = this.target.x - this.pos.x;
        this.faceLeft = (dx < 0);
        this.pos.x += clamp(dx, -SPEEDS.walk*dt, SPEEDS.walk*dt);
        if (Math.abs(dx) < 2){ this.state='CLIMB_Y'; }
        break;
      }
      case 'CLIMB_Y': {
        const dy = this.target.y - this.pos.y;
        this.pos.y += clamp(dy, -SPEEDS.climb*dt, SPEEDS.climb*dt);
        if (Math.abs(dy) < 2){
          this.state='EDIT';
          this.holdUntil = performance.now() + RULES.holdTimeMs;
        }
        break;
      }
      case 'EDIT': {
        if (performance.now() >= this.holdUntil){ this.state='DESCEND_Y'; }
        break;
      }
      case 'DESCEND_Y': {
        const dy = this.floorY - this.pos.y;
        this.pos.y += clamp(dy, -SPEEDS.climb*dt, SPEEDS.climb*dt);
        if (Math.abs(dy) < 2){
          this.state='EXIT';
          this.faceLeft = (this.exitSide < 0);
        }
        break;
      }
      case 'EXIT': {
        const dir = this.exitSide;
        this.pos.x += dir * SPEEDS.exit * dt;
        if (this.pos.x < -120 || this.pos.x > canvas.width+120){ this.done = true; }
        break;
      }
    }
  }

  draw(t){
    const sheet = (this.kind==='robot') ? SPRITES.robot : SPRITES.human;

    let view = 'side';
    if (!this.isNewUser){
      if (this.state==='CLIMB_Y' || this.state==='DESCEND_Y') view = 'back';
      if (this.state==='EDIT')    view = 'back';
    }

    // Stationary ladder (skip for new users)
    if (!this.isNewUser && (this.state==='CLIMB_Y' || this.state==='DESCEND_Y' || this.state==='EDIT')){
      drawLadderAnchored(this.target.x + OFFSETS[this.kind].x, this.floorY, this.target.y);
    }

    const xo = OFFSETS[this.kind].x, yo = OFFSETS[this.kind].y;

    // ----------------- NEW: glow for new users -----------------
    if (this.isNewUser){
      ctx.save();
      ctx.shadowColor = 'rgba(255, 220, 0, 0.9)'; // bright yellow
      ctx.shadowBlur = 25;                         // adjust softness
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    const {w,h} = sheet ? sheet.draw(view, t, this.pos.x + xo, this.pos.y + yo, !this.faceLeft)
                        : drawFallback(this.pos.x + xo, this.pos.y + yo);

    if (this.isNewUser){
      ctx.restore(); // remove glow so labels/badges don’t inherit it
    }
    // ------------------------------------------------------------

    this.actorRect = { x: this.pos.x + xo - w/2, y: this.pos.y + yo - h, w, h };

    // Small name label (still respects displayName() = '' to hide)
    ctx.font = '12px ui-monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = 'rgba(240,250,255,.95)';
    const isBot = (this.kind === 'robot');
    ctx.fillText(displayName(this.rawUser, isBot), this.pos.x, this.pos.y + 4);

    // Article badge only during shelf EDIT
    this.titleRect = null;
    if (!this.isNewUser && this.state==='EDIT'){
      const side = this.faceLeft ? 'left' : 'right';
      const gap  = 10;
      const anchorX = (side === 'right')
        ? (this.actorRect.x + this.actorRect.w + gap)
        : (this.actorRect.x - gap);
      const anchorY = this.actorRect.y + 16;
      this.titleRect = drawTitleBadge(
        this.title, anchorX, anchorY, side,
        { maxWidth: Math.min(300, canvas.width*0.26), padding: 8, lineHeight: 16 }
      );
    }

    // ----------------- NEW: floating “New User!” callout -----------------
    if (this.isNewUser && this.newUserCalloutShown){
      const elapsed = performance.now() - this.calloutT0;
      const tNorm = Math.min(1, Math.max(0, elapsed / this.calloutMs));
      // ease-out (quadratic)
      const ease = 1 - (1 - tNorm) * (1 - tNorm);
      const floatPx = 24;                      // upward drift
      const y = this.actorRect.y - 10 - ease * floatPx;
      const alpha = 1 - tNorm;                 // fade out

      ctx.save();
      ctx.globalAlpha = alpha;

      // // Optional: if you want to use the overlay image, draw it just above head:
      // if (SPRITES.nuover){
      //   const ow = SPRITES.nuover.width * 0.25;
      //   const oh = SPRITES.nuover.height * 0.25;
      //   ctx.drawImage(SPRITES.nuover, this.pos.x - ow/2, y - oh - 6, ow, oh);
      // }

      // Text badge (compact)
      ctx.font = 'bold 14px ui-monospace, SFMono-Regular, Menlo, monospace';
      const text = 'New User!';
      const pad  = 6;
      const tw   = ctx.measureText(text).width;
      const bw   = tw + pad*2;
      const bh   = 20 + pad*2;

      // dark pill behind text
      ctx.fillStyle = 'rgba(255, 220, 0, 0.9)';
      roundRectPath(ctx, this.pos.x - bw/2, y - bh, bw, bh, 10);
      ctx.fill();

      // text
      ctx.fillStyle = '#222';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, this.pos.x, y - bh/2);
      ctx.restore();
    }
  }

}


/* vector fallbacks */
function drawFallback(x,y){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle = '#aef'; ctx.beginPath(); ctx.arc(0,-18,16,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ccd'; ctx.fillRect(-10,-18,20,28);
  ctx.restore();
  return {w:20,h:44};
}
function drawLadderAnchored(x, floorY, targetY){
  const sideGap = OFFSETS.ladder.sideGap;
  const top = targetY - OFFSETS.ladder.topHeadroom;
  const bottom = floorY + 12;

  ctx.save();
  ctx.strokeStyle = 'rgba(180,120,60,.9)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x - sideGap, top);    ctx.lineTo(x - sideGap, bottom);
  ctx.moveTo(x + sideGap, top);    ctx.lineTo(x + sideGap, bottom);

  const rungs = 6;
  for (let i=0; i<=rungs; i++){
    const yy = lerp(top, bottom - 8, i/rungs);
    ctx.moveTo(x - sideGap, yy);   ctx.lineTo(x + sideGap, yy);
  }
  ctx.stroke();
  ctx.restore();
}


/* =======================
   Simulation
   ======================= */
const state = {
  actors: [],
  queue: []
};

function spawnActor({ isBot, rawUser, wikiHost, title }){
  const slot = pickArticleSlot(title);
  const side = (Math.random()<0.5) ? -1 : 1;
  const actor = new Actor(
    isBot ? 'robot' : 'human',
    rawUser,
    wikiHost,
    title,
    side,
    slot.row,
    { x: slot.x, y: slot.y }
  );
  if (state.actors.length < RULES.maxActors) state.actors.push(actor);
  else state.queue.push(actor);
}

function spawnNewUser({ rawUser, wikiHost }){
  // Always start at LEFT, walk to RIGHT, on ground floor (row = 3)
  const startSide = -1;
  const groundRow = 3;
  const yFloor    = floorYForShelfRow(groundRow);

  // We’ll set a simple “target” X far to the right; Y is the floor line
  const targetX = canvas.width + 120;
  const targetY = yFloor;

  const actor = new Actor(
    'human',                 // use human sheet (or robot if you prefer)
    rawUser,
    wikiHost,
    '(new user)',            // no article title involved
    startSide,
    groundRow,
    { x: targetX, y: targetY },
    { isNewUser: true }      // <-- extra flags/options
  );

  if (state.actors.length < RULES.maxActors) state.actors.push(actor);
  else state.queue.push(actor);
}



function step(dt){
  // promote queued actors if space
  while (state.actors.length < RULES.maxActors && state.queue.length){
    state.actors.push(state.queue.shift());
  }
  // update & cull
  for (const a of state.actors) a.update(dt);
  for (let i=state.actors.length-1;i>=0;i--) if (state.actors[i].done) state.actors.splice(i,1);
}

function draw(t){
  // clear the frame
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // overlay with transparency (railings, frames, etc.)
  ctx.drawImage(SPRITES.out, 0, 0, canvas.width, canvas.height);

  // base background
  ctx.drawImage(SPRITES.bg, 0, 0, canvas.width, canvas.height);

  // actors
  const tt = performance.now() / 1000;
  for (const a of state.actors) a.draw(tt);

  // new user overlay
  ctx.drawImage(SPRITES.nuover, 0, 0, canvas.width, canvas.height);

}


/* =======================
   Main loop
   ======================= */
let last = performance.now();
let paused = false;
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;
  if (!paused){ step(dt); draw(now/1000); }
  requestAnimationFrame(loop);
}

/* =======================
   EventStreams hookup
   ======================= */
const statusEl = document.getElementById('status');
const selProject = document.getElementById('language');
const sampleNEl  = document.getElementById('sampleN');
const onlyEditsEl= document.getElementById('onlyEdits');
let es=null, counter=0;

function connectStream(){
  if (es) es.close();
  statusEl.textContent='connecting…';
  es = new EventSource('https://stream.wikimedia.org/v2/stream/recentchange');
  es.onopen = ()=> statusEl.textContent='live';
  es.onerror= ()=> statusEl.textContent='error / reconnecting…';
  es.onmessage = (ev)=>{
    let e; try{ e = JSON.parse(ev.data); } catch{ return; }

    // project filter
    const wantProject = selProject.value.trim();
    if (wantProject && e.server_name !== wantProject) return;

    // If it’s a NEW-USER event, spawn ground-floor walker and bail early
    if (isNewUserEvent(e)){
      const rawUser = e.user || '(new user)';
      const wikiHost = e.server_name || 'en.wikipedia.org';
      spawnNewUser({ rawUser, wikiHost });
      return;
    }

    // namespace filter for edits only
    if (String(e.namespace) !== (RULES.namespace)) return;

    // Normal edit → shelf runner
    const title   = e.title || '(untitled)';
    const rawUser = e.user || '—';
    const wikiHost= e.server_name || 'en.wikipedia.org';
    const isBot   = e.bot === true;

    spawnActor({ isBot, rawUser, wikiHost, title });

    // const nameForLog = displayName(rawUser, isBot);
    // logLine(`[${e.wiki}] ${isBot ? '🤖' : '🧑'} ${nameForLog} → ${title}`);
  };

}

// // Reconnect on control changes
[selProject].forEach(el => el.addEventListener('change', connectStream));

/* =======================
   Boot
   ======================= */
(async function boot(){
  // load images
  try {
    SPRITES.out = await loadImage(ASSETS.outdoors.src);
  } catch(e){ console.warn('Outdoors failed to load'); }
  try {
    SPRITES.bg = await loadImage(ASSETS.background.src);
  } catch(e){ console.warn('Background failed to load'); }
  try {
    const rimg = await loadImage(ASSETS.robot.img.src);
    SPRITES.robot = new Sheet(rimg, ASSETS.robot.frames, ASSETS.robot.frames.scale);
  } catch(e){ console.warn('Robot sheet failed to load'); }
  try {
    const himg = await loadImage(ASSETS.human.img.src);
    SPRITES.human = new Sheet(himg, ASSETS.human.frames, ASSETS.human.frames.scale);
  } catch(e){ console.warn('Human sheet failed to load'); }
  try {
    SPRITES.nuover = await loadImage(ASSETS.newuseroverlay.src);
  } catch(e){ console.warn('New user overlay failed to load'); }

  connectStream();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
